<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Luxurious Gesture Christmas Tree</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }
        body {
            background-color: #000;
            overflow: hidden;
            font-family: 'Cinzel', serif; /*ä»¥æ­¤å­—ä½“è¥é€ é«˜çº§æ„Ÿï¼Œè‹¥æ— åˆ™å›é€€*/
            color: #d4af37;
        }

        /* 3D å®¹å™¨ */
        #canvas-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }
        
        /* éšè—è§†é¢‘æµ */
        #input_video { position: absolute; width: 1px; height: 1px; opacity: 0; pointer-events: none; z-index: -1; }

        /* UI å±‚ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 30px;
        }

        /* æ ‡é¢˜ */
        .header {
            text-align: center;
            pointer-events: none;
        }
        h1 {
            font-size: 2rem; letter-spacing: 0.5rem; text-transform: uppercase;
            background: linear-gradient(135deg, #fff 0%, #d4af37 50%, #8a6e2f 100%);
            -webkit-background-clip: text; color: transparent;
            text-shadow: 0 0 30px rgba(212, 175, 55, 0.3);
            margin-bottom: 10px;
        }
        .subtitle { font-size: 0.8rem; color: rgba(255,255,255,0.5); letter-spacing: 0.2rem; }

        /* åº•éƒ¨æ§åˆ¶æ  */
        .footer {
            display: flex; justify-content: space-between; align-items: flex-end;
            pointer-events: auto;
        }
        
        .gesture-guide {
            font-size: 0.75rem; color: rgba(255,255,255,0.4); line-height: 1.8;
            border-left: 2px solid #d4af37; padding-left: 15px;
        }
        .gesture-icon { font-size: 1.2rem; margin-right: 5px; vertical-align: middle; }

        /* ä¸Šä¼ æŒ‰é’® */
        #upload-btn {
            background: rgba(212, 175, 55, 0.1);
            border: 1px solid #d4af37; color: #d4af37;
            padding: 10px 24px; border-radius: 2px;
            font-family: inherit; letter-spacing: 2px; font-size: 0.8rem;
            cursor: pointer; transition: all 0.3s ease;
            text-transform: uppercase;
        }
        #upload-btn:hover { background: #d4af37; color: #000; box-shadow: 0 0 20px rgba(212, 175, 55, 0.4); }
        #file-input { display: none; }

        /* åŠ è½½é®ç½© */
        #loader {
            position: absolute; inset: 0; background: #000; z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 0.8s ease; pointer-events: auto;
        }
        .spinner {
            width: 50px; height: 50px; border: 2px solid rgba(212,175,55,0.1);
            border-top: 2px solid #d4af37; border-radius: 50%;
            animation: spin 1s infinite linear; margin-bottom: 20px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        /* çŠ¶æ€æŒ‡ç¤ºå™¨ */
        #status-indicator {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 1.5rem; letter-spacing: 0.5rem; color: rgba(255,255,255,0.1);
            pointer-events: none; mix-blend-mode: overlay; opacity: 0; transition: opacity 0.5s;
        }
    </style>

    <!-- Import Map for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    
    <!-- Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <!-- GSAP for smooth animations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
</head>
<body>

    <video id="input_video" playsinline webkit-playsinline></video>
    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div class="header">
            <h1>NoÃ«l Luxe</h1>
            <div class="subtitle">AI GESTURE INTERACTIVE TREE</div>
        </div>
        
        <div id="status-indicator">EXPLODE</div>

        <div class="footer">
            <div class="gesture-guide">
                <div><span class="gesture-icon">âœŠ</span> æ¡æ‹³ Â· èšåˆ</div>
                <div><span class="gesture-icon">ğŸ–</span> å¼ æ‰‹ Â· æ•£å¼€</div>
                <div><span class="gesture-icon">ğŸ‘Œ</span> æåˆ Â· æŠ“å–ç…§ç‰‡</div>
            </div>
            <div>
                <button id="upload-btn" onclick="document.getElementById('file-input').click()">Upload Photos</button>
                <input type="file" id="file-input" multiple accept="image/*">
            </div>
        </div>
    </div>

    <div id="loader">
        <div class="spinner"></div>
        <div style="font-size: 0.8rem; letter-spacing: 0.2rem; opacity: 0.7;">INITIALIZING VISION...</div>
        <button id="start-btn" style="margin-top:20px; padding:10px 30px; border:1px solid #d4af37; background:transparent; color:#d4af37; display:none; cursor:pointer;">ENTER</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- é…ç½® ---
        const CONFIG = {
            colors: {
                green: 0x0f3b1e, // å“‘å…‰åœ£è¯ç»¿
                gold: 0xffd700,  // å¥¢åé‡‘
                red: 0x8a0303,   // åœ£è¯çº¢
                bg: 0x050505
            },
            tree: {
                height: 14,
                radius: 6,
                levels: 15
            },
            counts: {
                ornaments: 800,
                particles: 1500
            }
        };

        // --- å…¨å±€çŠ¶æ€ ---
        const state = {
            mode: 'TREE', // TREE, EXPLODE, ZOOM
            lerpVal: 0,   // 0 = Tree, 1 = Explode
            handPos: { x: 0, y: 0 },
            isPinching: false,
            zoomIndex: -1,
            photos: [] // textures
        };

        // --- Three.js å˜é‡ ---
        let scene, camera, renderer, composer;
        let ornamentsInstanced, photoGroup, particleSystem;
        let clock = new THREE.Clock();
        
        // æ•°æ®å­˜å‚¨
        const ornamentsData = []; // { treePos, explodePos, ... }
        const photoMeshes = [];
        const dummy = new THREE.Object3D();
        const _vec3 = new THREE.Vector3();

        // --- åˆå§‹åŒ– ---
        function init() {
            // 1. Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.bg);
            scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.02);

            // 2. Camera (Cinematic FOV)
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 25);

            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            // å…³é”®ï¼šç”µå½±çº§è‰²è°ƒæ˜ å°„
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // 4. Post Processing (Bloom)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.2;
            bloomPass.strength = 1.5; // å¼ºè¾‰å…‰
            bloomPass.radius = 0.5;
            
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // 5. Lights
            setupLights();

            // 6. Objects
            createOrnaments();
            createParticles();
            
            // é»˜è®¤åŠ è½½å‡ å¼ å ä½å›¾
            loadDefaultPhotos();

            // Events
            window.addEventListener('resize', onResize);
            
            // Start Loop
            animate();
        }

        function setupLights() {
            const ambient = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambient);

            // ä¸»é‡‘å…‰
            const spotGold = new THREE.SpotLight(CONFIG.colors.gold, 100);
            spotGold.position.set(10, 20, 10);
            spotGold.angle = 0.6;
            spotGold.penumbra = 1;
            spotGold.castShadow = true;
            scene.add(spotGold);

            // è¡¥å…‰çº¢
            const pointRed = new THREE.PointLight(CONFIG.colors.red, 20, 20);
            pointRed.position.set(-10, 5, 5);
            scene.add(pointRed);
            
            // åº•éƒ¨å†·å…‰è¡¬æ‰˜
            const pointBlue = new THREE.PointLight(0x4444ff, 10, 20);
            pointBlue.position.set(0, -10, 5);
            scene.add(pointBlue);
        }

        // --- æ ¸å¿ƒï¼šåˆ›å»ºè£…é¥°ç‰© (InstancedMesh) ---
        function createOrnaments() {
            // ä½¿ç”¨ Icosahedron æ¨¡æ‹Ÿçƒä½“/å¤šé¢ä½“ï¼Œæ€§èƒ½å¥½ä¸”åå…‰å¥½çœ‹
            const geometry = new THREE.IcosahedronGeometry(0.3, 1);
            
            // å¥¢åæè´¨ï¼šé«˜é‡‘å±åº¦
            const material = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.3,
                metalness: 0.9,
                envMapIntensity: 1.0
            });

            ornamentsInstanced = new THREE.InstancedMesh(geometry, material, CONFIG.counts.ornaments);
            const color = new THREE.Color();

            for (let i = 0; i < CONFIG.counts.ornaments; i++) {
                // 1. è®¡ç®—æ ‘å½¢æ€ä½ç½® (èºæ—‹åœ†é”¥)
                const y = (Math.random() - 0.5) * CONFIG.tree.height;
                const relY = (y + CONFIG.tree.height/2) / CONFIG.tree.height; // 0~1
                const r = (1 - relY) * CONFIG.tree.radius; // é¡¶éƒ¨çª„ï¼Œåº•éƒ¨å®½
                const theta = i * 0.1 + Math.random(); // èºæ—‹
                
                const treePos = new THREE.Vector3(
                    Math.cos(theta) * r,
                    y,
                    Math.sin(theta) * r
                );

                // 2. è®¡ç®—æ•£å¼€å½¢æ€ä½ç½® (çƒä½“éšæœºåˆ†å¸ƒ)
                const expR = 15 + Math.random() * 10;
                const phi = Math.acos(2 * Math.random() - 1);
                const expTheta = Math.random() * Math.PI * 2;
                
                const explodePos = new THREE.Vector3(
                    expR * Math.sin(phi) * Math.cos(expTheta),
                    expR * Math.sin(phi) * Math.sin(expTheta),
                    expR * Math.cos(phi)
                );

                // 3. é¢œè‰²åˆ†é…
                const rand = Math.random();
                if (rand > 0.6) color.setHex(CONFIG.colors.gold);
                else if (rand > 0.3) color.setHex(CONFIG.colors.green);
                else color.setHex(CONFIG.colors.red);
                
                ornamentsInstanced.setColorAt(i, color);

                // å­˜å‚¨æ•°æ®
                ornamentsData.push({
                    treePos,
                    explodePos,
                    velocity: Math.random() * 0.02,
                    offset: Math.random() * 100
                });

                // åˆå§‹ä½ç½®
                dummy.position.copy(treePos);
                dummy.updateMatrix();
                ornamentsInstanced.setMatrixAt(i, dummy.matrix);
            }
            
            scene.add(ornamentsInstanced);
        }

        // --- æ ¸å¿ƒï¼šç…§ç‰‡äº‘ ---
        function createPhotos(textures) {
            if(photoGroup) scene.remove(photoGroup);
            photoGroup = new THREE.Group();
            photoMeshes.length = 0;

            textures.forEach((tex, i) => {
                // ä¿æŒé•¿å®½æ¯”ï¼ŒåŠ ä¸Šé‡‘è¾¹æ¡†
                const imgAspect = tex.image.width / tex.image.height;
                const width = 3; 
                const height = width / imgAspect;

                const geometry = new THREE.PlaneGeometry(width, height);
                const material = new THREE.MeshBasicMaterial({ 
                    map: tex, 
                    side: THREE.DoubleSide 
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                
                // é‡‘è¾¹
                const borderGeo = new THREE.PlaneGeometry(width + 0.2, height + 0.2);
                const borderMat = new THREE.MeshStandardMaterial({ 
                    color: CONFIG.colors.gold, metalness: 1.0, roughness: 0.2 
                });
                const border = new THREE.Mesh(borderGeo, borderMat);
                border.position.z = -0.01;
                mesh.add(border);

                // ä½ç½®è®¡ç®—
                // æ ‘å½¢æ€ï¼šéšè—åœ¨æ ‘å†…éƒ¨
                const treePos = new THREE.Vector3(0, (Math.random()-0.5)*8, 0);
                
                // æ•£å¼€å½¢æ€ï¼šç¯ç»•
                const angle = (i / textures.length) * Math.PI * 2;
                const r = 8;
                const explodePos = new THREE.Vector3(
                    Math.cos(angle) * r,
                    (Math.random()-0.5) * 6,
                    Math.sin(angle) * r
                );

                mesh.userData = {
                    treePos, 
                    explodePos,
                    baseScale: 0.0, // æ ‘å½¢æ€ä¸‹ä¸å¯è§
                    targetScale: 1.0
                };
                
                // åˆå§‹çŠ¶æ€
                mesh.position.copy(treePos);
                mesh.scale.set(0,0,0);
                mesh.lookAt(camera.position);

                photoGroup.add(mesh);
                photoMeshes.push(mesh);
            });
            scene.add(photoGroup);
        }

        // --- æ ¸å¿ƒï¼šGPU ç²’å­ç‰¹æ•ˆ (Shader) ---
        function createParticles() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const randoms = [];

            for(let i=0; i<CONFIG.counts.particles; i++) {
                positions.push((Math.random()-0.5)*40, (Math.random()-0.5)*40, (Math.random()-0.5)*40);
                randoms.push(Math.random());
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uLerp: { value: 0 }, // 0=Tree, 1=Explode
                    uColor: { value: new THREE.Color(CONFIG.colors.gold) }
                },
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending,
                vertexShader: `
                    uniform float uTime;
                    uniform float uLerp;
                    attribute float aRandom;
                    varying float vAlpha;
                    
                    void main() {
                        vec3 pos = position;
                        
                        // æ ‘å½¢æ€ï¼šèºæ—‹ä¸Šå‡çš„ç²’å­æµ
                        float angle = uTime * 0.5 + aRandom * 10.0;
                        float r = 5.0 * (1.0 - (pos.y + 7.0)/14.0); // ç®€å•çš„åœ†é”¥çº¦æŸ
                        vec3 treePos = vec3(cos(angle)*r, pos.y, sin(angle)*r);
                        
                        // æ•£å¼€å½¢æ€ï¼šåŸæœ¬çš„éšæœºä½ç½® + æ¼‚æµ®
                        vec3 explodePos = pos + vec3(sin(uTime+aRandom)*2.0, cos(uTime*0.5)*2.0, 0.0);
                        
                        // æ’å€¼
                        vec3 finalPos = mix(treePos, explodePos, uLerp);
                        
                        vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                        gl_Position = projectionMatrix * mvPosition;
                        
                        // å¤§å°éšè·ç¦»è¡°å‡
                        gl_PointSize = (4.0 * aRandom + 2.0) * (1.0 / -mvPosition.z);
                        
                        vAlpha = 0.5 + 0.5 * sin(uTime * 3.0 + aRandom * 10.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 uColor;
                    varying float vAlpha;
                    void main() {
                        float d = distance(gl_PointCoord, vec2(0.5));
                        if(d > 0.5) discard;
                        float glow = 1.0 - d * 2.0;
                        glow = pow(glow, 2.0);
                        gl_FragColor = vec4(uColor, vAlpha * glow);
                    }
                `
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
        }

        // --- é€»è¾‘ï¼šåŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();
            
            // 1. çŠ¶æ€å¹³æ»‘è¿‡æ¸¡ (GSAP-like lerp)
            const target = (state.mode === 'TREE') ? 0 : 1;
            state.lerpVal += (target - state.lerpVal) * 0.05;

            // 2. è£…é¥°ç‰©åŠ¨ç”»
            for (let i = 0; i < CONFIG.counts.ornaments; i++) {
                const data = ornamentsData[i];
                
                // ä½ç½®æ’å€¼
                _vec3.lerpVectors(data.treePos, data.explodePos, state.lerpVal);
                
                // æ•£å¼€æ—¶çš„æ¼‚æµ®åŠ¨ç”»
                if (state.lerpVal > 0.1) {
                    _vec3.y += Math.sin(time + data.offset) * 0.5 * state.lerpVal;
                    _vec3.x += Math.cos(time * 0.5 + data.offset) * 0.2 * state.lerpVal;
                }

                dummy.position.copy(_vec3);
                
                // æ—‹è½¬
                dummy.rotation.set(time, time * 0.5, 0);
                
                // ç¼©æ”¾ (æ ‘å½¢æ€å°ä¸€ç‚¹ï¼Œæ•£å¼€å¤§ä¸€ç‚¹)
                const s = 1 + state.lerpVal * 0.5;
                dummy.scale.set(s, s, s);
                
                dummy.updateMatrix();
                ornamentsInstanced.setMatrixAt(i, dummy.matrix);
            }
            ornamentsInstanced.instanceMatrix.needsUpdate = true;

            // 3. ç…§ç‰‡åŠ¨ç”»
            photoMeshes.forEach((mesh, i) => {
                const data = mesh.userData;
                
                if (state.mode === 'ZOOM' && state.zoomIndex === i) {
                    // æ”¾å¤§æ€ï¼šé£åˆ°ç›¸æœºé¢å‰
                    // è®¡ç®—ç›¸æœºå‰æ–¹ä½ç½®
                    const camDir = new THREE.Vector3();
                    camera.getWorldDirection(camDir);
                    const targetPos = camera.position.clone().add(camDir.multiplyScalar(5));
                    
                    mesh.position.lerp(targetPos, 0.1);
                    mesh.scale.lerp(new THREE.Vector3(1.5, 1.5, 1.5), 0.1);
                    mesh.lookAt(camera.position); // æ°¸è¿œæœå‘ç›¸æœº
                } else {
                    // æ™®é€šæ€ (æ ‘æˆ–æ•£å¼€)
                    const targetPos = new THREE.Vector3().lerpVectors(data.treePos, data.explodePos, state.lerpVal);
                    // æ•£å¼€æ—¶æ¼‚æµ®
                    if(state.lerpVal > 0.5) targetPos.y += Math.sin(time + i) * 0.5;
                    
                    mesh.position.lerp(targetPos, 0.05);
                    
                    // æ ‘å½¢æ€æ—¶ä¸æ˜¾ç¤º
                    const s = state.lerpVal; 
                    mesh.scale.set(s, s, s);
                    
                    mesh.lookAt(camera.position);
                }
            });

            // 4. ç²’å­ Shader æ›´æ–°
            if(particleSystem) {
                particleSystem.material.uniforms.uTime.value = time;
                particleSystem.material.uniforms.uLerp.value = state.lerpVal;
            }

            // 5. ç›¸æœºäº¤äº’ (è§†å·®æ—‹è½¬)
            if (state.mode !== 'TREE') {
                // æ ¹æ®æ‰‹çš„ä½ç½®è½»å¾®æ—‹è½¬ç›¸æœºï¼Œåˆ¶é€ ç©ºé—´æ„Ÿ
                const targetX = state.handPos.x * 5; 
                const targetY = state.handPos.y * 5;
                camera.position.x += (targetX - camera.position.x) * 0.05;
                camera.position.y += (targetY - camera.position.y) * 0.05;
                camera.lookAt(0, 0, 0);
            } else {
                // æ ‘å½¢æ€å¤ä½
                camera.position.lerp(new THREE.Vector3(0, 0, 25), 0.05);
                camera.lookAt(0, 0, 0);
            }

            composer.render();
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- é€»è¾‘ï¼šç…§ç‰‡ä¸Šä¼  ---
        function loadDefaultPhotos() {
            const urls = [
                "https://images.unsplash.com/photo-1543589077-47d81606c1bf?w=500&q=80", // è£…é¥°
                "https://images.unsplash.com/photo-1512389142860-9c449e58a543?w=500&q=80", // ç¤¼ç‰©
                "https://images.unsplash.com/photo-1511895426328-dc8714191300?w=500&q=80", // é›ªæ™¯
                "https://images.unsplash.com/photo-1543258103-a62bdc069871?w=500&q=80"  // èšä¼š
            ];
            const loader = new THREE.TextureLoader();
            const textures = urls.map(url => {
                const t = loader.load(url);
                t.colorSpace = THREE.SRGBColorSpace;
                return t;
            });
            createPhotos(textures);
        }

        document.getElementById('file-input').addEventListener('change', (e) => {
            const files = e.target.files;
            if(files.length === 0) return;
            
            const textures = [];
            let loaded = 0;
            
            for(let i=0; i<files.length; i++) {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const img = new Image();
                    img.src = ev.target.result;
                    img.onload = () => {
                        const tex = new THREE.Texture(img);
                        tex.colorSpace = THREE.SRGBColorSpace;
                        tex.needsUpdate = true;
                        textures.push(tex);
                        loaded++;
                        if(loaded === files.length) createPhotos(textures);
                    }
                };
                reader.readAsDataURL(files[i]);
            }
        });

        // --- è§†è§‰ï¼šMediaPipe æ‰‹åŠ¿è¯†åˆ« ---
        async function initVision() {
            const video = document.getElementById('input_video');
            const startBtn = document.getElementById('start-btn');
            const loaderDiv = document.getElementById('loader');
            const statusInd = document.getElementById('status-indicator');

            try {
                const hands = new Hands({locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }});

                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 0, // Lite mode for mobile performance
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                hands.onResults((results) => {
                    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                        const lm = results.multiHandLandmarks[0];
                        
                        // 1. è·å–æ‰‹æŒä¸­å¿ƒ (è§†å·®æ§åˆ¶)
                        // Mediapipe x is 0-1, left-right inverted
                        state.handPos.x = (0.5 - lm[9].x) * 4; 
                        state.handPos.y = (0.5 - lm[9].y) * 4;

                        // 2. æ‰‹åŠ¿è¯†åˆ«
                        const wrist = lm[0];
                        const tips = [8, 12, 16, 20]; // 4 fingers (excl thumb)
                        const bases = [5, 9, 13, 17];
                        let extended = 0;
                        
                        // è®¡ç®—ä¼¸ç›´çš„æ‰‹æŒ‡æ•°é‡
                        for(let i=0; i<4; i++) {
                            const dTip = Math.hypot(lm[tips[i]].x - wrist.x, lm[tips[i]].y - wrist.y);
                            const dBase = Math.hypot(lm[bases[i]].x - wrist.x, lm[bases[i]].y - wrist.y);
                            if(dTip > dBase * 1.3) extended++;
                        }

                        // æåˆæ£€æµ‹ (Pinch): Index Tip (8) vs Thumb Tip (4)
                        const pinchDist = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
                        const isPinch = pinchDist < 0.05;

                        // çŠ¶æ€æœºé€»è¾‘
                        if (state.mode === 'EXPLODE' && isPinch) {
                            // è¿›å…¥æŠ“å–æ”¾å¤§æ¨¡å¼
                            if (!state.isPinching) {
                                state.isPinching = true;
                                state.mode = 'ZOOM';
                                // ç®€å•é€»è¾‘ï¼šéšæœºæŠ“ä¸€å¼ ï¼Œæˆ–æŠ“æœ€è¿‘çš„ä¸€å¼ 
                                state.zoomIndex = Math.floor(Math.random() * photoMeshes.length);
                                showStatus("ZOOM");
                            }
                        } else if (!isPinch) {
                            state.isPinching = false;
                            
                            if (extended >= 3) {
                                // å¼ æ‰‹ -> æ•£å¼€
                                if (state.mode !== 'EXPLODE') {
                                    state.mode = 'EXPLODE';
                                    showStatus("EXPLODE");
                                }
                            } else if (extended <= 1) {
                                // æ¡æ‹³ -> èšåˆ
                                if (state.mode !== 'TREE') {
                                    state.mode = 'TREE';
                                    state.zoomIndex = -1;
                                    showStatus("TREE");
                                }
                            }
                        }
                    }
                });

                const camera = new Camera(video, {
                    onFrame: async () => { await hands.send({image: video}); },
                    width: 640, height: 480
                });
                
                await camera.start();
                
                // Ready
                loaderDiv.querySelector('div:nth-child(2)').innerText = "SYSTEM READY";
                loaderDiv.querySelector('.spinner').style.display = 'none';
                startBtn.style.display = 'block';
                startBtn.onclick = () => {
                    loaderDiv.style.opacity = 0;
                    setTimeout(() => loaderDiv.remove(), 800);
                    init(); // å¯åŠ¨3D
                };

            } catch(e) {
                console.error(e);
                alert("Camera access denied or error. Please use HTTPS.");
            }
        }

        function showStatus(text) {
            const el = document.getElementById('status-indicator');
            el.innerText = text;
            el.style.opacity = 1;
            setTimeout(() => el.style.opacity = 0, 1000);
        }

        // å¯åŠ¨è§†è§‰è¯†åˆ«
        initVision();

    </script>
</body>
</html>